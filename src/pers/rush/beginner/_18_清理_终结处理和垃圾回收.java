package pers.rush.beginner;

class A {

    String name = "";

    public A(String name) {
        super();
        this.name = name;
    }

    @Override
    protected void finalize() throws Throwable {
        /*
         * 当classA的实例对象被垃圾回收器回收的时候被调用 一般叫做终结方法
         */
        super.finalize(); // 也要调用父类的终结方法
        System.out.println(name + "对象被销毁了");
    }
}

public class _18_清理_终结处理和垃圾回收 {

    public static void main(String[] args) {
        /*
         * java里面有垃圾回收器 假如使用的对象不一定都是new出来的 假如调用了非java代码,获得的对象 垃圾回收器只会回收new出来的对象
         * 为了应对这种情况,java定义了特殊的方法finalize() 一旦垃圾回收器准备好释放对象占用的存储空间,那么首先会调用finalize()方法
         * 并且在下一次垃圾回收动作发生的时候,才真正回收对象占用的内存
         */

        A aObj = new A("Tom");
        aObj = null;
        System.gc();

        /*
         * finalize()是不能作为真正的清理方法的 垃圾回收是跟内存有关的
         * 
         */

        /*
         * [垃圾回收] 
         * java采用的方式: 查找活的对象，静态存储区遍历引用，把引用指向的对象标记为活的对象。活的对象如果还有其他对象的引用，就再深入遍历。
         * 没有被引用的对象就是垃圾，可以被自动回收。
         * 还采用自适应的方式。 找正在使用的对象，每种jvm实现的方式不同。有一种是停止-复制。
         * 【停止，复制】把程序暂停，然后把所有存活的对象，从当前堆里面复制到另一个堆里面，没有被复制的就全部都是垃圾了。新堆里面的对象排列是紧凑的。旧堆可以清空重用。
         * 变量的引用指向新堆的地址上。 缺点：运行的程序要暂停，进行复制工作。效率较低.
         * 缺点1: 得有两个堆，在两个堆之间转移。 所需的空间需要多出来一倍。
         * 某些Java虚拟机的处理方式是按需从堆里面分配几块大的内存。
         * 缺点2: 程序进入稳定状态之后，只产生少量垃圾，甚至没有。这种情况下，垃圾回收开始工作，对象拷贝做的是无用功，更浪费资源。
         * 如果程序写得好，这种方式浪费资源。
         * 检查有没有新的垃圾产生，如果没有，使用另外一种方式。
         * 【标记-清扫】 早期Sun公司用的是这种方式
         * 速度相当慢，依据思路是堆栈和静态存储区遍历引用，找出存活的对象，加上标记。
         * 过程不回收任何对象。当全部对象标记完后，开始清理工作。
         * 没有标记为活的对象，就会被释放。剩下的堆空间通常是不连续的。
         * 如果希望得到连续空间的话, 还得重新整理空间.
         * Java垃圾回收器是一种自适应方式：自己检查，垃圾产生比较少时，采用标记-清扫。
         * 垃圾比较多时，用停止-复制。
         * JVM会跟踪垃圾清理效果，自动切换两种清理方式。
         * 自适应的分代的停止-复制/标记-清扫式垃圾回收器.
         */
    }

}
