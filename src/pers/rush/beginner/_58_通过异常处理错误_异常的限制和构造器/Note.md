- 当方法被子类覆盖的时候,只能抛出在基类方法中列出的异常(除运行时异常)
- 意味着当基类使用的代码应用到派生类对象的时候,依然能工作
- 原因:  
主要是因为多态的问题,父类的引用可以指向子类,调用该(新抛出非运行时异常)重写的方法  
这种非运行时异常必须强制声明try-catch块才可以  
如果子类有多出来的非运行时异常,编译工具只会根据父类的引用变量来判断是否有非运行时异常  
如果有这种情况存在的话  
那么就无法在新添加的方法被调用的时候判断出来,针对非运行时异常的try-catch块是否写了(Java语法规定要写)    